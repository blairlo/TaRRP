---
title: "BayWeeklyAnalysis"
author: "Logan"
date: "5/31/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descriptive Statistics

# Prelims
```{r}
library(sf)
library(raster)
library(stringr)
library(questionr)
library(dplyr)
library(rgdal)
library(rgeos)
library(ggplot2)
library(MASS)
library(pscl)
library(reshape2)
library(data.table)
require(caTools)
library(tidycensus)
library(stargazer)
library(exactextractr)
library(ordinal)
library(estimatr)
library(osmextract)
library(ggeffects)
library(VGAM)
library(car)
library(units)
library(DescTools)
library(brant)
library(MatchIt)
library(vtable)
```

### Handy summary function for caluclating SE
```{r}
## form the R cookbook http://www.cookbook-r.com/Manipulating_data/Summarizing_data/
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summarized
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
    library(plyr)

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm=FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    # This does the summary. For each group's data frame, return a vector with
    # N, mean, and sd
    datac <- ddply(data, groupvars, .drop=.drop,
      .fun = function(xx, col) {
        c(N    = length2(xx[[col]], na.rm=na.rm),
          mean = mean   (xx[[col]], na.rm=na.rm),
          sd   = sd     (xx[[col]], na.rm=na.rm)
        )
      },
      measurevar
    )

    # Rename the "mean" column    
    datac <- rename(datac, c("mean" = measurevar))

    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

    # Confidence interval multiplier for standard error
    # Calculate t-statistic for confidence interval: 
    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
    ciMult <- qt(conf.interval/2 + .5, datac$N-1)
    datac$ci <- datac$se * ciMult

    return(datac)
}
```


# Load Data

### Downloaded shapefiles and measurments
```{r}
ProjectCRS = 2882 #Make project coordinate system

NInstall_Predicted<-st_read("Building Data/NInstall_Predicted.shp")%>%
                              st_transform(ProjectCRS) %>% #pull in time series
                              mutate(Program = 0)

Install_Predicted<-st_read("Building Data/Install_Predicted.shp")%>%
                              st_transform(ProjectCRS)%>% #pull in time series
                              dplyr::select(-TarpP6)%>%
                              mutate(Program = 1)

CInstall_Predicted<-rbind(NInstall_Predicted,Install_Predicted)


CInstall_Predicted$FootprintArea <- st_area(CInstall_Predicted)
CInstall_Predicted$FootprintArea<-drop_units(CInstall_Predicted$FootprintArea)

Parcels<-st_read("Building Data/Parcels.shp")%>%
                              st_transform(ProjectCRS)
                                  
BayCounty<-st_read("OtherGeoData/Bay_County.shp")%>%
                              st_transform(ProjectCRS)

MichaelWind<- st_read("OtherGeoData/Michael_ATL_2018_1minMaxSus_OT_FtptSwath_BandedShp_12Oct_0600UTC_v1_Hwind_A.shp")%>%
                    st_transform(ProjectCRS)

#load and convert sign up locations to points
ROELocation<- read.csv("Building Data/ROECenters.csv")%>%
                st_as_sf(coords = c("Longitude", "Latitude"), crs = 4269)%>%
                  st_transform(crs = ProjectCRS)

```

### Census areas and stats
```{r}
census_api_key("11f26f3fa4866e02a16340fa7037d3811ded2275")

ACSCodebook <- load_variables(2017, "acs5", cache = TRUE)
#View(ACSCodebook)

BGstats <- get_acs( #download blocks/blockgroup/tracts from Census API
                        state = "FL", # designate state
                        geography = "block group", # neighborhood level
                        variables = c("population" = "B01001_001",
                                      "households" = "B11001_001",
                                      "income" = "B19013_001", #household income
                                      "white" = "B02001_002",
                                      "bachelors" = "B15003_022",
                                      "vehicles" = "B992512_002",
                                      "internet" = "B28002_002",
                                      "smartphone" = "B28001_005"), #Return population (must pick at least 1 var to run)
                        output = "wide",
                        year = 2017,
                        survey = "acs5",
                        geometry = TRUE
                        )%>%
                          
                      #make BG level percentages (per capita or per household if measured at the household level)
                      mutate("whiteP" = whiteE/populationE,
                             "nonwhiteP" = 1 - whiteP,
                             "bachelorsP" = bachelorsE/populationE,
                             "vehiclesP" = vehiclesE/populationE,
                             "internetP" = internetE/householdsE,
                             "smartphoneP" = whiteE/householdsE)%>%
                      dplyr::rename(BG_GEOID = GEOID)%>%
                      st_transform(ProjectCRS)%>% # reproject
                      st_crop(BayCounty) #clip to study area

```

### OSM Neighborhood features
Acquiring distances between properties and n neighborhood attributes is laborious depending on the availability of spatialized data at the county/state/US level from many sources (e.g. local GIS websites, US DOT).

One solution is to use Open Street Map, which is an open source mapping application hosted by University
College London, similar to google maps and on a global scale, but with the main difference being we can
download it feature by feature.

**Download OSM features as sf object for state**
I use the osmextract package (https://github.com/ropensci/osmextract) as opposed to the more popular
osmdata package because of its ability to download entire states worth of data quickly without timeout
problems. There were also some discrepancies in the osmdata package downloads we could not reconcile
with online maps. This does not seem to be an issue with osmextract.
```{r}

run = "N"

if (run=="Y") {

#set Geography
OSMRegion ="US-FL"
County= "BAY"


#Download all OSM polygons for FL
osm_poly<- oe_get(OSMRegion,
layer = "multipolygons",
stringsAsFactors = FALSE,
quiet = TRUE)

osm_poly<-st_transform(osm_poly, crs = ProjectCRS) #reproject
osm_poly<-st_make_valid(osm_poly) #fixes "dangles" and other hand drawing issues
osm_poly<-st_crop(osm_poly,BayCounty)# reduce data to neighborhood level


#Download all OSM points for FL
osm_points<- oe_get(OSMRegion,
layer = "points",
stringsAsFactors = FALSE,
quiet = TRUE)
osm_points<-st_transform(osm_points, crs = ProjectCRS) #reproject
osm_points<-st_make_valid(osm_points) #fixes "dangles" and other hand drawing issues
osm_points<-st_crop(osm_points,BayCounty)# reduce data to neighborhood level


#Download all OSM polylines for FL
osm_line<- oe_get(OSMRegion,
layer = "lines",
stringsAsFactors = FALSE,
quiet = TRUE)

osm_line<-st_transform(osm_line, crs = ProjectCRS)
osm_line<-st_make_valid(osm_line)
osm_line<-st_crop(osm_line,BayCounty)

st_write(osm_poly, "OtherGeoData/osm_poly_Bay.shp")
st_write(osm_points, "OtherGeoData/osm_points_Bay.shp")
st_write(osm_line, "OtherGeoData/osm_line_Bay.shp")


} else {
  
  #osm_poly <-st_read("OtherGeoData/osm_poly_Bay.shp")
  #osm_points <-st_read("OtherGeoData/osm_points_Bay.shp")
  osm_line <- st_read("OtherGeoData/osm_line_Bay.shp")
}

```

#Make Full Data Set
```{r}
#spatial joins
TarpTimeUnfilter <- CInstall_Predicted%>%
                    #st_centroid() %>% #make footprint points
                    st_join(Parcels, left = TRUE, largest=TRUE) %>% #append parcel attribute to footprint Point
                    st_join(MichaelWind, left = TRUE, largest=TRUE) %>%
                    st_join(BGstats, left = TRUE, largest=TRUE) %>%
                    dplyr::rename(FootprintID=GlblIDF, ParcelID=GlobalID) #make different id names for footprints and parcels
                

#The following block contains a user defined function that determines the distance from X to Feature Y in Var Y in Layer Y 
DistToNear<- function(LayerX, LayerY, VarY, FeatureY){ #4 arguments
      extract<-subset(LayerY, VarY==print(FeatureY)) #choose feature to measure to
      nearest<-st_nearest_feature(LayerX,extract) #make a list of nearest features
      dist<-st_distance(LayerX, extract[nearest,], by_element = TRUE) #return the distance
      attributesY<-st_drop_geometry(extract[nearest,]) #Collect attributes
      out<-as.data.frame(st_drop_geometry(cbind(LayerX[1],nearest,dist,attributesY))) #combine
}

# Run function to determine dist to nearest ROE signup and OSM neighborhood features
ROEDist<-DistToNear(LayerX = TarpTimeUnfilter,
                 LayerY = ROELocation,
                 VarY = ROELocation$ROESite,
                 FeatureY = "1"
                )
ROEDist$dist <- drop_units(ROEDist$dist)

InterstateDis<-DistToNear(LayerX = TarpTimeUnfilter,
                 LayerY = osm_line,
                 VarY = osm_line$highway,
                 FeatureY = "trunk"
                )

HighwayDist<-DistToNear(LayerX = TarpTimeUnfilter,
                 LayerY = osm_line,
                 VarY = osm_line$highway,
                 FeatureY = "primary"
                )

TarpTimeUnfilter <- TarpTimeUnfilter%>%
                              #join Signup Center Distance
                              left_join(ROEDist, by = "FootprintID")%>%
                                dplyr::rename(DistROE = dist)%>%

                              #Join Road Distances
                              left_join(InterstateDis, by = "FootprintID")%>%
                                dplyr::rename(DistInterstate = dist)%>%
  
                              left_join(HighwayDist, by = "FootprintID")%>%
                                dplyr::rename(DistHighway = dist)%>%
  
                                    #report closest distance between the two hwy types
                                    mutate(DistToHwy = ifelse(DistInterstate < DistHighway ,DistInterstate,DistHighway ))

#make zipcode a factor
TarpTimeUnfilter$DSITEZIP<-as.factor(TarpTimeUnfilter$DSITEZIP)
                 
```


### clean and make more interesting descriptive catagories and transformations
```{r}
#make new vars
TarpTime <- TarpTimeUnfilter%>%
                          mutate(Val_sqf = VAPBLDG/S1AREATTL,
                                 Val_sqf_med = ifelse(Val_sqf < median(Val_sqf), "BelowMedVal","AboveMeanVal"),
                                 sqft_stories = S1AREATTL/(ifelse(S1STORIES == 0, 1,S1STORIES)),
                                 age = (2019-S1YRBLTACT),
                                 LocalOwner = ifelse(A7MAILST == "FL", 1, 0),
                                 
                                 #make simpler building FE
                                 BuildingType = as.factor(ifelse(DORAPPDESC == "SINGLE FAMILY", "SINGLE FAMILY",
                                 ifelse(DORAPPDESC == "MULTI-FAMILY 10 LESS","MULTI-FAMILY",
                                 #ifelse(DORAPPDESC =="MULTI-FAMILY 10+ UTS","MULTI-FAMILY",
                                 ifelse(DORAPPDESC == "MOBILE HOME", "MOBILE HOME", "Other")))),
                                 )

#make single family base catagory                                 
TarpTime$BuildingType<-relevel(TarpTime$BuildingType, "SINGLE FAMILY")

#Select only tarped properties and remove outliers
TarpTime<-TarpTime%>%
                        dplyr::filter(!is.na(CovrPrd))%>%
                        dplyr::filter(!is.na(LocalOwner))%>%
                        dplyr::filter(!is.na(Val_sqf))%>%
                        dplyr::filter(is.finite(Val_sqf))%>%
                        dplyr::filter(
                                 BuildingType == "SINGLE FAMILY"
                                |BuildingType == "MOBILE HOME"
                                |BuildingType == "MULTI-FAMILY"
                               # |BuildingType == "Other"
                                )%>%
                                dplyr::filter(
                                 VAPTOTAL > 100
                                &VAPTOTAL < 10000000
                                &FootprintArea > 100
                                &FootprintArea < 10000
                                &Val_sqf > 0
                                &Val_sqf < 400
                                )
 
#Assessed Value quantiles
TarpTime <- TarpTime%>%
                          mutate(AssessValQaurtiles = 
                            ifelse(CutQ(Val_sqf) == "Q1","Q1AssessVal",
                            ifelse(CutQ(Val_sqf) == "Q2","Q2AssessVal",
                            ifelse(CutQ(Val_sqf) == "Q3","Q3AssessVal",
                            ifelse(CutQ(Val_sqf) == "Q4","Q4AssessVal",NA)))))

#Size quantiles
TarpTime <- TarpTime%>%
                          mutate(HomeSizeQaurtiles = 
                            ifelse(CutQ(FootprintArea) == "Q1","Q1(small)",
                            ifelse(CutQ(FootprintArea) == "Q2","Q2(medium)",
                            ifelse(CutQ(FootprintArea) == "Q3","Q3(large)",
                            ifelse(CutQ(FootprintArea) == "Q4","Q4(very large)",NA)))))
#Val quantiles
TarpTime <- TarpTime%>%
                          mutate(HomeValLS = 
                            ifelse(AssessValQaurtiles == "Q1AssessVal","BelowMeanVal",
                            ifelse(AssessValQaurtiles == "Q2AssessVal","BelowMeanVal",
                            ifelse(AssessValQaurtiles == "Q3AssessVal","AboveMeanVal",
                            ifelse(AssessValQaurtiles == "Q4AssessVal","AboveMeanVal"
                           ,NA)))))


TarpTime <- TarpTime%>%
                    mutate(CovrPrd2 = ifelse(CovrPrd >4 , 6, CovrPrd))

#Separate Program, Non Program, and Both
ProgramTarpTime<-filter(TarpTime, Program==1)
NProgramTarpTime<-filter(TarpTime, Program==0)

```

# Plot Descriptive Differences
```{r}

plot1a<-ggplot(summarySE(ProgramTarpTime, measurevar="CovrPrd", groupvars=c("HomeSizeQaurtiles")),
              aes(x=HomeSizeQaurtiles, y=CovrPrd, group=1))+
                geom_errorbar(width=.1, aes(ymin=CovrPrd-ci, ymax=CovrPrd+ci))+
                 geom_point(shape=21, size=3, fill="white")
plot1a

plot1b<-ggplot(summarySE(ProgramTarpTime, measurevar="CovrPrd", groupvars=c("AssessValQaurtiles")),
              aes(x=AssessValQaurtiles, y=CovrPrd, group=1))+
                geom_errorbar(width=.1, aes(ymin=CovrPrd-ci, ymax=CovrPrd+ci))+
                 geom_point(shape=21, size=3, fill="white")
plot1b

Plot2 <- ggplot(summarySE(ProgramTarpTime, measurevar="CovrPrd", groupvars=c("HomeSizeQaurtiles","HomeValLS")),
       aes(x=HomeSizeQaurtiles, y=CovrPrd, colour=HomeValLS, group=HomeValLS)) +
  
    geom_errorbar(aes(ymin=CovrPrd-se, ymax=CovrPrd+se), colour="black", width=.1) +
    geom_line() +
    geom_point( size=3, shape=21, fill="white") + # 21 is filled circle
    xlab("Home Size (Quartiles)") +
    ylab("Average Time Untill Installation (Weeks)") +
    scale_colour_hue(name="Assesed Home Value",    # Legend label, use darker colors
                     #labels=c("Below Median","Above Median"),
                     l=50, # Use darker colors, lightness=40
                     guide = guide_legend(reverse=TRUE)) +    
    theme_bw()+
            # Position legend in bottom right
    theme(legend.justification=c(.95,.95),
          legend.position=c(.95,.95))
Plot2

Plot3<- ggplot(ProgramTarpTime, aes(x = CovrPrd, y = HomeSizeQaurtiles  )) +
        geom_boxplot(size = .5) +
        geom_jitter(alpha = .1) +
        theme(axis.text.x = element_text( hjust = 1, vjust = 1))

Plot3


stat1 <- ddply(TarpTime, "Program", summarise, Val.stat1=mean(VAPTOTAL))
stat1

plot4 <- ggplot(TarpTime, aes(x=VAPTOTAL, fill=as.factor(Program))) +
    geom_histogram(binwidth=10000, alpha=.5, position="identity")+
    geom_vline(data=stat1, aes(xintercept=Val.stat1,  colour=as.factor(Program)),linetype="dashed", size=1)+
    scale_x_continuous(limits = c(0, 300000))

plot4


stat2 <- ddply(TarpTime, "Program", summarise, Val.stat2=mean(FootprintArea))
stat2

plot5 <- ggplot(TarpTime, aes(x=FootprintArea, fill=as.factor(Program))) +
    geom_histogram(binwidth=100, alpha=.5, position="identity")+
    geom_vline(data=stat2, aes(xintercept=Val.stat2,  colour=as.factor(Program)),linetype="dashed", size=1)+
    scale_x_continuous(limits = c(0, 5000))

plot5

#boxplots
plot6 <-ggplot(TarpTime, aes(x=as.factor(Program), y=Val_sqf, fill=as.factor(Program))) + 
    geom_boxplot() + 
    guides(fill=FALSE) + 
    coord_flip()+
    scale_y_continuous(limits = c(0, 200))
plot6

```

### Exploratory Regressions

OLS models
```{r}
#Intercept Only
Reg1 <- lm(CovrPrd~1, data = ProgramTarpTime)

#Base Reg
Reg2 <- lm(CovrPrd~
          log(FootprintArea)
          +Val_sqf
           , data = ProgramTarpTime)

#Property Level Controls
Reg3 <- lm(CovrPrd~
           log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           , data = ProgramTarpTime)

#Block Group socioeconomic controls
Reg4 <- lm(CovrPrd~
            log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           ,data = ProgramTarpTime)

# Zip Code FE
Reg5 <- lm(CovrPrd~
           log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + as.factor(DSITEZIP)
          , data = ProgramTarpTime)


summary(Reg1)
summary(Reg2)
summary(Reg3)
summary(Reg4)
summary(Reg5)

```

### Ordered Logit. 
In reality response times are not all evenly spaced and are more generalized "bins" that have order from fast to slow. 
```{r}
#Intercept Only
Reg1b <- clm(as.factor((CovrPrd/2)-1)~ 1
           , data = ProgramTarpTime)

#Base Reg
Reg2b <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           , data = ProgramTarpTime)


#Property Level Controls
Reg3b <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           , data = ProgramTarpTime)

#Block Group socioeconomic controls
Program <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           , data = ProgramTarpTime)

# Zip Code FE
ProgramFE <-  clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           , data = ProgramTarpTime)

        
summary(Reg1b)
summary(Reg2b)
summary(Reg3b)
summary(Program)
summary(ProgramFE)

```

```{r warning=FALSE}
#Test proportional odds assumptions

ProgramTarpTime$LFootprintArea<-log(ProgramTarpTime$FootprintArea)
ProgramTarpTime$LVal_sqf<-log(ProgramTarpTime$Val_sqf)
ProgramTarpTime$LX1mSWmphBnd<-log(ProgramTarpTime$X1mSWmphBnd)
ProgramTarpTime$LX1mSWmphBnd<-log(ProgramTarpTime$X1mSWmphBnd)

test3 <- polr(as.factor(((CovrPrd/2)-1))~
           LFootprintArea
           +Val_sqf
           +LX1mSWmphBnd
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           , data = ProgramTarpTime)

poTest(test3)
brant(test3)
```

### generlized/partial proportional odds (relaxed parallel assumption with intercept specific estimates)
```{r}
#Intercept Only
Reg1c <- clm(as.factor((CovrPrd/2)-1)~ 1
           , data = ProgramTarpTime)

#Base Reg
Reg2c <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +log(Val_sqf)
           , data = ProgramTarpTime)


#Property Level Controls
Reg3c <- clm(as.factor((CovrPrd/2)-1)~
          log(FootprintArea)
           +log(Val_sqf)
           +age+I(age^2)
           +BuildingType
           +DistToHwy
           +LocalOwner,
              nominal = ~
              log(X1mSWmphBnd)
              +DistROE
            , data = ProgramTarpTime)

#Block Group socioeconomic controls
Reg4c <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +log(Val_sqf)
           +age+I(age^2)
           +BuildingType
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP,
           nominal = ~
              log(X1mSWmphBnd)
              +DistROE
            , data = ProgramTarpTime)

# Zip Code FE
Reg5c <-  clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +log(Val_sqf)
           +age+I(age^2)
           #+BuildingType
           +DistToHwy
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP,
           nominal = ~
              log(X1mSWmphBnd)
              +DistROE
            , data = ProgramTarpTime)

        
summary(Reg1c)
summary(Reg2c)
summary(Reg3c)
summary(Reg4c)
summary(Reg5c)

```

## Matching
```{r}
### Treatment = size , match on val and obs #### 

#need a binary treatment large homes vs small homes (at least for a first cut)
ProgramTarpTimeSF<- ProgramTarpTime%>%
                      filter(BuildingType == "SINGLE FAMILY") %>%
                      st_drop_geometry()
                        SFMed<- quantile(ProgramTarpTimeSF$FootprintArea, 0.5)
                      
ProgramTarpTimeMF <- ProgramTarpTime%>%
                      filter(BuildingType == "MULTI-FAMILY") %>%
                      st_drop_geometry()
                        MFMed<- quantile(ProgramTarpTimeMF$FootprintArea, 0.5)

ProgramTarpTimeMo <- ProgramTarpTime%>%
                      filter(BuildingType == "MOBILE HOME") %>%
                       st_drop_geometry()
                        MoMed<- quantile(ProgramTarpTimeMo$FootprintArea, 0.5)
                        
ProgramTarpTimeOth <- ProgramTarpTime%>%
                      filter(BuildingType == "Other") %>%
                       st_drop_geometry()
                        OthMed<- quantile(ProgramTarpTimeOth$FootprintArea, 0.5)                        
                        
ProgramTarpTimeMatch<- ProgramTarpTime%>%
                      dplyr::mutate(SizeTreatLarge = ifelse(BuildingType == "SINGLE FAMILY" & FootprintArea > as.numeric(SFMed), 1,
                                              ifelse(BuildingType == "MULTI-FAMILY" & FootprintArea > as.numeric(MFMed), 1,
                                               ifelse(BuildingType == "MOBILE HOME" & FootprintArea > as.numeric(MoMed), 1,
                                               ifelse(BuildingType == "Other" & FootprintArea > as.numeric(OthMed), 1,
                                               0)))))

#Matched Set     
matchSize <- matchit(SizeTreatLarge ~ VAPTOTAL 
                                    +X1mSWmphBnd
                                    +age
                                    +BuildingType
                                    +DistROE
                                    +DistToHwy
                                    +LocalOwner
                                    +DSITEZIP
                                   ,data = ProgramTarpTimeMatch
                                   ,method = 'cem'
                                   ,k2k = TRUE
                                   , estimand = 'ATT'
                                  )

matchSizeSummary<-summary(matchSize)
matchSizeSummary
matchSize_df <- match.data(matchSize)

#simple difference
matchSize_Control<- matchSize_df%>%
                      filter(SizeTreatLarge==0)

matchSize_Control<- mean(matchSize_Control$CovrPrd)

matchSize_Treat<- matchSize_df%>%
                      filter(SizeTreatLarge==1)

matchSize_Treat<- mean(matchSize_Treat$CovrPrd)
matchSize_Treat-matchSize_Control


#Modeled
matchSize_model1 <- lm(((CovrPrd/2)-1) ~ SizeTreatLarge,data = matchSize_df, weights = weights)
matchSize_model2 <- clm(as.factor((CovrPrd/2)-1) ~ SizeTreatLarge, data = matchSize_df, weights = weights)

scale_test(matchSize_model2)

summary(matchSize_model1)
summary(matchSize_model2)

### Treatment = Val , match on size and obs ####

#making a binary treatment is additionally challenging when the data have different categories of building (e.g. single and multi family), this is conditioned for in a regression setting with continuous value, but here we must conditionally dichotomize treatment ahead of time, otherwise matching on building types will be difficult.


                        SFMedVal<- quantile(ProgramTarpTimeSF$VAPTOTAL, 0.5)
                        MFMedVal<- quantile(ProgramTarpTimeMF$VAPTOTAL, 0.5)
                        MoMedVal<- quantile(ProgramTarpTimeMo$VAPTOTAL, 0.5)
                       OthMedVal<- quantile(ProgramTarpTimeOth$VAPTOTAL, 0.5)


ProgramTarpTimeMatch2<- ProgramTarpTime%>%
                      dplyr::mutate(ValTreatLarge = ifelse(BuildingType == "SINGLE FAMILY" & VAPTOTAL > as.numeric(SFMedVal), 1,
                                              ifelse(BuildingType == "MULTI-FAMILY" & VAPTOTAL > as.numeric(MFMedVal), 1,
                                               ifelse(BuildingType == "MOBILE HOME" & VAPTOTAL > as.numeric(MoMedVal), 1,
                                               ifelse(BuildingType == "Other" & VAPTOTAL > as.numeric(OthMedVal), 1,
                                               0)))))

#Matched Set     
matchVal <- matchit(ValTreatLarge ~ FootprintArea 
                                    + X1mSWmphBnd
                                    +age
                                    +BuildingType
                                    +DistROE
                                    +DistToHwy
                                    +LocalOwner
                                    +DSITEZIP
                                   ,data = ProgramTarpTimeMatch2
                                   ,method = 'cem'
                                   ,k2k = TRUE
                                   , estimand = 'ATT'
                                  )

matchValSummary<-summary(matchVal, un=TRUE)
matchValSummary
matchVal_df <- match.data(matchVal)

#simple difference
matchVal_Control<- matchVal_df%>%
                      filter(ValTreatLarge==0)

matchVal_Control<- mean(matchVal_Control$CovrPrd)

matchVal_Treat<- matchVal_df%>%
                      filter(ValTreatLarge==1)
matchVal_Treat<- mean(matchVal_Treat$CovrPrd)
matchVal_Treat-matchVal_Control


#Modeled
matchVal_model <- clm(as.factor((CovrPrd/2)-1) ~ ValTreatLarge, data = matchVal_df, weights = weights)
scale_test(matchVal_model)
summary(matchVal_model)


```

# Non-Program Results
Ordered Logit
```{r}
#Intercept Only
Reg1d <- clm(as.factor((CovrPrd/2)-1)~ 1
           , data = NProgramTarpTime)

#Base Reg
Reg2d <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           , data = NProgramTarpTime)


#Property Level Controls
Reg3d <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           , data = NProgramTarpTime)

#Block Group socioeconomic controls
NonProgram <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           , data = NProgramTarpTime)

# Zip Code FE
NonProgramFE <-  clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           #+BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           , data = NProgramTarpTime)

        
summary(Reg1d)
summary(Reg2d)
summary(Reg3d)
summary(NonProgram)
summary(NonProgramFE)


```

#Combined Results
```{r}
#Intercept Only
Reg1e <- clm(as.factor((CovrPrd/2)-1)~ 1
           , data = TarpTime)

#Base Reg
Reg2e <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           , data = TarpTime)

#Property Level Controls
Reg3e <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)*Program
           +log(Val_sqf)*Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           , data = TarpTime)

#Block Group socioeconomic controls
Reg4e <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           , data = TarpTime)

# Zip Code FE
Reg5e <-  clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           , data = TarpTime)
        
summary(Reg1e)
summary(Reg2e)
summary(Reg3e)
summary(Reg4e)
summary(Reg5e)

```

### Matching For Non-Program Counterfactual
```{r}
#Matched Set     
matchProgram <- matchit(Program ~ 
                                    +FootprintArea
                                    +Val_sqf
                                   # +S1STORIES
                                   # +S1BATHRMS
                                    +X1mSWmphBnd
                                    +age 
                                    +BuildingType
                                    +DistROE
                                    +DistToHwy
                                    +LocalOwner
                                   # +nonwhiteP
                                   # +bachelorsP
                                   # +internetP
                                   # +smartphoneP
                                    +DSITEZIP
                                   ,data = TarpTime
                                   ,method = "cem"
                                   ,k2k = TRUE
                                   ,estimand = 'ATT'
                                  )

matchProgram_df <- match.data(matchProgram)

```

Matching Summaries
```{r}
summary(matchProgram)

matchIndicator <- matchProgram_df %>%
                 dplyr::select(FootprintID)%>%
                 mutate(matched=1)%>%
                 st_drop_geometry()
 

SummaryDat<-TarpTime%>%
          st_drop_geometry()%>%
          left_join(matchIndicator, by="FootprintID")%>% 
            mutate(status = (ifelse(is.na(matched) & Program == 1,"Unmatched_Program", 
                             ifelse(is.na(matched) & Program == 0,"Unmatched_NonProgram", 
                             ifelse(matched == 1 & Program == 1,"Matched_Program", 
                             ifelse(matched == 1 & Program == 0,"Matched_NonProgram", NA))))))

MatchingSummary<- SummaryDat%>%
  dplyr::group_by(status)%>%
  dplyr::summarize(mean(VAPTOTAL),
                   n())

MatchingSummary

```

Program and NonProgram Summary Stats
```{r}
## summary table

DatasummaryP<- ProgramTarpTime%>%
                dplyr::select(
                       FootprintArea,
                       VAPTOTAL,
                       Val_sqf,
                       X1mSWmphBnd,
                       age,
                       BuildingType,
                       DistROE,
                       DistToHwy,
                       LocalOwner,
                       nonwhiteP,
                       bachelorsP,
                       internetP,
                       smartphoneP
                       )%>%
                        st_drop_geometry()

DatasummaryNP<- NProgramTarpTime%>%
                dplyr::select(
                       FootprintArea,
                       VAPTOTAL,
                       Val_sqf,
                       X1mSWmphBnd,
                       age,
                       BuildingType,
                       DistROE,
                       DistToHwy,
                       LocalOwner,
                       nonwhiteP,
                       bachelorsP,
                       internetP,
                       smartphoneP
                       )%>%
                        st_drop_geometry()

MatchedDat<- SummaryDat%>%
                dplyr::select(
                       FootprintArea,
                       VAPTOTAL,
                       Val_sqf,
                       X1mSWmphBnd,
                       age,
                       BuildingType,
                       DistROE,
                       DistToHwy,
                       LocalOwner,
                       nonwhiteP,
                       bachelorsP,
                       internetP,
                       smartphoneP,
                       status
                       )

MatchedDattable<-st(MatchedDat, group = 'status', group.test = FALSE)


stargazer(DatasummaryP,DatasummaryNP,Unmatched_Program,
                  out = paste(getwd(),"/Summary.html", sep=""),
                  type = "html", #change to latex for final
                  min.max = FALSE,
                  median = TRUE
                  )
```

Matched, Ordered Logit
```{r}
#Intercept Only
Reg1f <- clm(as.factor((CovrPrd/2)-1)~ 1
           ,data = filter(matchProgram_df, Program==0))

#Base Reg
Reg2f <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
            +Val_sqf
            #+Program
            ,data = filter(matchProgram_df, Program==0))

#Property Level Controls
Reg3f <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)
           +Val_sqf
           #+Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           ,data = filter(matchProgram_df, Program==0))

#Block Group socioeconomic controls
Reg4f <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +Val_sqf
           #+Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +S1STORIES
           +S1BATHRMS
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           , data = filter(matchProgram_df, Program==0))

# Zip Code FE
Reg5f <-  clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)
           +Val_sqf
           #+Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           , data = filter(matchProgram_df, Program==0))

        
summary(Reg1f)
summary(Reg2f)
summary(Reg3f)
summary(Reg4f)
summary(Reg5f)

```

Matched, Ordered Logit, interacted
```{r}
#Intercept Only
Reg1g <- clm(as.factor((CovrPrd/2)-1)~ 1
           , data = matchProgram_df)

#Base Reg
Regtest <- clm(as.factor((CovrPrd/2)-1)~
            Program
           ,data = matchProgram_df)

#Base Reg
Reg2g <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           ,data = matchProgram_df)

#Property Level Controls
Reg3g <- clm(as.factor((CovrPrd/2)-1)~
           log(FootprintArea)*Program
           +log(Val_sqf)*Program 
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           ,data = matchProgram_df)

#Block Group socioeconomic controls
Reg4g <- clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           , data = matchProgram_df)

# Zip Code FE
Reg5g <-  clm(as.factor((CovrPrd/2)-1)~
            log(FootprintArea)*Program
           +log(Val_sqf)*Program
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           , data = matchProgram_df)

# Zip Code FE
test <-  clm(as.factor((CovrPrd/2)-1)~
               Program
          # +log(FootprintArea)
           +log(Val_sqf)
           +log(X1mSWmphBnd)
           +age+I(age^2)
           +BuildingType
           +DistROE
           +DistToHwy
           +LocalOwner
           +S1STORIES
           +S1BATHRMS
           +nonwhiteP
           +bachelorsP
           +internetP
           +smartphoneP
           + DSITEZIP
           ,data = matchProgram_df)

summary(Reg1g)
summary(Reg2g)
summary(Reg3g)
summary(Reg4g)
summary(Reg5g)

```

### Make reg and summary tables
```{r}
table1<-stargazer(Reg1, Reg2, Reg3,  Reg4, Reg5,
                  title="Regression Results (OLS)",
                  align=TRUE, 
                  dep.var.labels=c("Response Time (weeks)"),
                  #covariate.labels=c("Handling of Complaints",
                  #                  "No Special Privileges",
                  #                  "Opportunity to Learn",
                  #                  "Performance-Based Raises",
                  #                  "Too Critical","
                  #                  Advancement"),
                  omit.stat=c("LL","ser","f"), 
                  #se = starprep(Reg5, clusters = ProgramTarpTime$DSITEZIP),
                  omit=c("DSITEZIP"),
                  add.lines=list(c('Zip Code FE', 'No','No','No','No','Yes')),
                  out = paste(getwd(),"/RegTable1.html", sep=""),
                  type = "html", #change to latex for final
                  no.space=TRUE)

table2<-stargazer(Reg1a, Reg2a, Reg3a,  Reg4a, Reg5a,
                  title="Regression Results (Poission)",
                  align=TRUE, 
                  dep.var.labels=c("Response Time (period counts 0 to 4)"),
                  #covariate.labels=c("Handling of Complaints",
                  #                  "No Special Privileges",
                  #                  "Opportunity to Learn",
                  #                  "Performance-Based Raises",
                  #                  "Too Critical","
                  #                  Advancement"),
                  omit.stat=c("LL","ser","f"), 
                  omit=c("DSITEZIP"),
                  add.lines=list(c('Zip Code FE', 'No','No','No','No','Yes')),
                  out = paste(getwd(),"/RegTable2.html", sep=""),
                  type = "html", #change to latex for final
                  no.space=TRUE)


table3<-stargazer(Reg1b, Reg2b, Reg3b,  Reg4b, Reg5b,
                  title="Regression Results (Ordered Logit)",
                  align=TRUE, 
                  dep.var.labels=c("Response Time (Catagories 0 to 4)"),
                  #covariate.labels=c("Handling of Complaints",
                  #                  "No Special Privileges",
                  #                  "Opportunity to Learn",
                  #                  "Performance-Based Raises",
                  #                  "Too Critical","
                  #                  Advancement"),
                  omit.stat=c("LL","ser","f"), 
                  omit=c("DSITEZIP"),
                  ord.intercepts = TRUE,
                  add.lines=list(c('Zip Code FE', 'No','No','No','No','Yes','Yes')),
                  out = paste(getwd(),"/RegTable3.html", sep=""),
                  type = "html", #change to latex for final
                  no.space=TRUE)

table4<-stargazer(Reg3c, Reg4c, Reg5c,
                  title="Partial proportional odds (intercept specific estimates)",
                  align=TRUE, 
                  dep.var.labels=c("Response Time (Catagories 0 to 4)"),
                  #covariate.labels=c("Handling of Complaints",
                  #                  "No Special Privileges",
                  #                  "Opportunity to Learn",
                  #                  "Performance-Based Raises",
                  #                  "Too Critical","
                  #                  Advancement"),
                  omit.stat=c("LL","ser","f"), 
                  omit=c("DSITEZIP"),
                  ord.intercepts = TRUE,
                  add.lines=list(c('Zip Code FE','No','No','Yes')),
                  out = paste(getwd(),"/RegTable4.html", sep=""),
                  type = "html", #change to latex for final
                  no.space=TRUE)

tableX<-stargazer(Reg4b, Reg5b, Reg4d,Reg5d,Reg4f,Reg5f,Reg4g,Reg5g,
                  title="Proportional Odds Models)",
                  align=TRUE, 
                  #object.names = TRUE,
                  dep.var.labels=c("Response Time (Catagories 0 to 5)"),
                  #covariate.labels=c("Handling of Complaints",
                  #                  "No Special Privileges",
                  #                  "Opportunity to Learn",
                  #                  "Performance-Based Raises",
                  #                  "Too Critical","
                  #                  Advancement"),
                  omit.stat=c("LL","ser","f"), 
                  omit=c("DSITEZIP"),
                  ord.intercepts = TRUE,
                  add.lines=list(c('Zip Code FE','No','Yes','No','Yes','No','Yes','No','Yes')),
                  out = paste(getwd(),"/RegTableX.html", sep=""),
                  type = "html" #change to latex for final
                  )

```




